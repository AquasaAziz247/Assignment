Got it — I rewrote the **14 assignment programs in Java**. Each program is a self-contained `.java` file with a `main` method and a usage note. These are practical, assignment-level lexical utilities (not full compilers); they handle typical student C source code and common edge cases (strings, comments, escapes) but are not guaranteed to handle every pathological C corner case.

Paste each file into its own `.java` file (filename matches the public class name), compile with `javac`, run with `java`. If you want, I can instead pack everything into a single multi-command program or create a Maven project — say the option number from the previous message and I’ll produce that.

---

# 1) `CountTokens.java` — count keywords, identifiers, operators, numbers, special symbols (file input)

Usage: `java CountTokens source.c`

```java
// CountTokens.java
import java.io.*;
import java.util.*;

public class CountTokens {
    static final Set<String> KEYWORDS = new HashSet<>(Arrays.asList(
        "printf","scanf","int","float","char","for","while","if","else","break"
    ));

    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java CountTokens source.c"); return; }
        FileInputStream fis = new FileInputStream(args[0]);
        Reader r = new InputStreamReader(fis);
        int ch;
        StringBuilder token = new StringBuilder();
        long kw=0, id=0, num=0, op=0, special=0;
        String ops = "+-*/%=<>!&|^~";
        while ((ch = r.read()) != -1) {
            char c = (char) ch;
            if (Character.isLetter(c) || c=='_') {
                token.append(c);
                while ((ch = r.read())!=-1) {
                    c=(char)ch;
                    if (Character.isLetterOrDigit(c) || c=='_') token.append(c);
                    else { r.reset(); break; }
                    r.mark(1);
                }
                String s = token.toString();
                token.setLength(0);
                if (KEYWORDS.contains(s)) kw++; else id++;
            } else if (Character.isDigit(c)) {
                StringBuilder number = new StringBuilder();
                number.append(c);
                while ((ch = r.read())!=-1) {
                    c=(char)ch;
                    if (Character.isDigit(c) || c=='.') number.append(c);
                    else { r.reset(); break; }
                    r.mark(1);
                }
                num++;
            } else {
                if (ops.indexOf(c)>=0) op++;
                else if (!Character.isWhitespace(c)) special++;
            }
            r.mark(1);
        }
        r.close();
        System.out.println("Keywords: "+kw);
        System.out.println("Identifiers: "+id);
        System.out.println("Numbers: "+num);
        System.out.println("Operators: "+op);
        System.out.println("Special symbols: "+special);
    }
}
```

---

# 2) `RemoveCommentsWhitespace.java` — remove `//`, `/*...*/` comments and compress extra whitespace

Usage: `java RemoveCommentsWhitespace source.c > cleaned.c`

```java
// RemoveCommentsWhitespace.java
import java.io.*;

public class RemoveCommentsWhitespace {
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java RemoveCommentsWhitespace source.c"); return; }
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuilder out = new StringBuilder();
        int state = 0; // 0 normal,1 slash,2 line-comment,3 block-comment,4 string
        int ch;
        while ((ch = br.read()) != -1) {
            char c = (char) ch;
            if (state==0) {
                if (c=='/') { state=1; }
                else if (c=='"') { out.append(c); state=4; }
                else if (Character.isWhitespace(c)) {
                    if (out.length()>0 && !Character.isWhitespace(out.charAt(out.length()-1))) out.append(' ');
                } else out.append(c);
            } else if (state==1) {
                if (c=='/') { state=2; }
                else if (c=='*') { state=3; }
                else { out.append('/'); out.append(c); state=0; }
            } else if (state==2) {
                if (c=='\n') { out.append('\n'); state=0; }
            } else if (state==3) {
                if (c=='*') {
                    br.mark(1);
                    int nx = br.read();
                    if (nx== -1) break;
                    if ((char)nx == '/') state=0;
                    else br.reset();
                }
            } else if (state==4) {
                out.append(c);
                if (c=='\\') { int nx = br.read(); if (nx!=-1) out.append((char)nx); }
                else if (c=='"') state=0;
            }
        }
        br.close();
        System.out.print(out.toString());
    }
}
```

---

# 3) `Lexemes.java` — extract and print lexemes/tokens

Usage: `java Lexemes source.c`

```java
// Lexemes.java
import java.io.*;
import java.util.*;

public class Lexemes {
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java Lexemes source.c"); return; }
        FileReader fr = new FileReader(args[0]);
        StreamTokenizer st = new StreamTokenizer(fr);
        st.ordinaryChars('0','9'); // let numbers be tokens we handle manually
        st.wordChars('_', '_');
        st.wordChars('0','9'); // allow words with digits
        List<String> tokens = new ArrayList<>();
        int t;
        while ((t = st.nextToken()) != StreamTokenizer.TT_EOF) {
            if (t==StreamTokenizer.TT_WORD) tokens.add(st.sval);
            else if (t==StreamTokenizer.TT_NUMBER) tokens.add(String.valueOf(st.nval));
            else { tokens.add(String.valueOf((char)st.ttype)); }
        }
        fr.close();
        System.out.println(String.join(", ", tokens));
    }
}
```

---

# 4) `ClassifyWords.java` — for a single input line, classify each word as keyword, identifier, or constant

Usage: `echo "int a = 5;" | java ClassifyWords`

```java
// ClassifyWords.java
import java.io.*;
import java.util.*;

public class ClassifyWords {
    static final Set<String> KEYWORDS = new HashSet<>(Arrays.asList(
        "int","float","return","char","for","while","if","else","break","scanf","printf"
    ));
    private static boolean isNumber(String s){
        try { Double.parseDouble(s); return true; } catch(Exception e) { return false; }
    }
    private static boolean isIdentifier(String s){
        if (s.isEmpty()) return false;
        if (!(Character.isLetter(s.charAt(0)) || s.charAt(0)=='_')) return false;
        for (int i=1;i<s.length();i++) {
            char c=s.charAt(i);
            if (!(Character.isLetterOrDigit(c) || c=='_')) return false;
        }
        return !KEYWORDS.contains(s);
    }
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = br.readLine();
        if (line==null) return;
        String[] parts = line.split("\\s+|(?=[;=+\\-*/%(){}\\[\\],])|(?<=[;=+\\-*/%(){}\\[\\],])");
        for (String p: parts) {
            if (p.trim().isEmpty()) continue;
            if (KEYWORDS.contains(p)) System.out.println(p+" : keyword");
            else if (isNumber(p)) System.out.println(p+" : constant");
            else if (isIdentifier(p)) System.out.println(p+" : identifier");
            else System.out.println(p+" : unknown");
        }
    }
}
```

---

# 5) `CategorizeOperators.java` — categorize operators into arithmetic, relational, logical

Usage: `echo "a==b && c+d" | java CategorizeOperators`

```java
// CategorizeOperators.java
import java.io.*;

public class CategorizeOperators {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = br.readLine(); if (line==null) return;
        for (int i=0;i<line.length(); ){
            char c = line.charAt(i);
            if (Character.isWhitespace(c)) { i++; continue; }
            if ("+-*/%".indexOf(c)>=0) {
                System.out.println("Arithmetic: "+c); i++;
            } else if ((c=='=' || c=='!' || c=='<' || c=='>') && i+1<line.length() && line.charAt(i+1)=='=') {
                System.out.println("Relational: "+c+line.charAt(i+1)); i+=2;
            } else if (c=='<'||c=='>') {
                System.out.println("Relational: "+c); i++;
            } else if (c=='&' && i+1<line.length() && line.charAt(i+1)=='&') {
                System.out.println("Logical: &&"); i+=2;
            } else if (c=='|' && i+1<line.length() && line.charAt(i+1)=='|') {
                System.out.println("Logical: ||"); i+=2;
            } else if (c=='!') { System.out.println("Logical: !"); i++; }
            else i++;
        }
    }
}
```

---

# 6) `RecognizeConstants.java` — recognize integer, float, character constants in a line

Usage: `echo "int x = 45; float y = 4.5; char c = 'a';" | java RecognizeConstants`

```java
// RecognizeConstants.java
import java.io.*;

public class RecognizeConstants {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = br.readLine(); if (s==null) return;
        for (int i=0;i<s.length();){
            char c = s.charAt(i);
            if (c=='\'') {
                int j=i+1;
                if (j<s.length() && s.charAt(j)=='\\') j+=2;
                else j++;
                if (j<s.length() && s.charAt(j)=='\'') {
                    System.out.println("Character: "+s.substring(i,j+1));
                    i=j+1; continue;
                } else { i++; }
            } else if (Character.isDigit(c)) {
                int j=i; boolean dot=false;
                while (j<s.length() && (Character.isDigit(s.charAt(j)) || s.charAt(j)=='.')) {
                    if (s.charAt(j)=='.') dot=true;
                    j++;
                }
                if (dot) System.out.println("Float: "+s.substring(i,j)); else System.out.println("Integer: "+s.substring(i,j));
                i=j; continue;
            } else i++;
        }
    }
}
```

---

# 7) `StringLiterals.java` — extract string literals from a source file

Usage: `java StringLiterals source.c`

```java
// StringLiterals.java
import java.io.*;

public class StringLiterals {
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java StringLiterals source.c"); return; }
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        int ch; boolean inString=false; StringBuilder sb = new StringBuilder();
        while ((ch = br.read())!=-1) {
            char c = (char) ch;
            if (!inString) {
                if (c=='"') { inString=true; sb.append(c); }
            } else {
                sb.append(c);
                if (c=='\\') { int nx=br.read(); if (nx!=-1) sb.append((char)nx); else break; }
                else if (c=='"') { System.out.println(sb.toString()); sb.setLength(0); inString=false; }
            }
        }
        br.close();
    }
}
```

---

# 8) `SummaryCounts.java` — total lines, tokens (approx), comments (approx)

Usage: `java SummaryCounts source.c`

```java
// SummaryCounts.java
import java.io.*;

public class SummaryCounts {
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java SummaryCounts source.c"); return; }
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String line; long lines=0, tokens=0, comments=0;
        while ((line = br.readLine())!=null) {
            lines++;
            String t = line;
            // remove string literals to avoid counting tokens inside them
            t = t.replaceAll("\"(\\\\.|[^\"\\\\])*\"", " ");
            // count // comments
            int idx = t.indexOf("//");
            if (idx!=-1) { comments++; t = t.substring(0, idx); }
            // count /* */ occurrences (simple)
            if (t.contains("/*")) comments++;
            // approximate tokens: split by whitespace and punctuation
            String[] parts = t.split("\\s+|(?=[{}();,\\[\\]])|(?<=[{}();,\\[\\]])");
            for (String p: parts) if (p.trim().length()>0) tokens++;
        }
        br.close();
        System.out.println("Total number of lines: "+lines);
        System.out.println("Total number of tokens (approx): "+tokens);
        System.out.println("Total number of comments (approx): "+comments);
    }
}
```

---

# 9) `ValidIdentifier.java` — check if a string is a valid C identifier and not a keyword

Usage: `java ValidIdentifier _count1`

```java
// ValidIdentifier.java
import java.util.*;

public class ValidIdentifier {
    static final Set<String> KEYWORDS = new HashSet<>(Arrays.asList(
        "auto","break","case","char","const","continue","default","do","double","else","enum","extern",
        "float","for","goto","if","int","long","register","return","short","signed","sizeof","static",
        "struct","switch","typedef","union","unsigned","void","volatile","while","scanf","printf","break"
    ));
    public static boolean isValid(String s) {
        if (s==null || s.isEmpty()) return false;
        char c = s.charAt(0);
        if (!(Character.isLetter(c) || c=='_')) return false;
        for (int i=1;i<s.length();i++) {
            char ch = s.charAt(i);
            if (!(Character.isLetterOrDigit(ch) || ch=='_')) return false;
        }
        return !KEYWORDS.contains(s);
    }
    public static void main(String[] args) {
        if (args.length!=1) { System.out.println("Usage: java ValidIdentifier identifier"); return; }
        System.out.println(args[0] + (isValid(args[0]) ? " → Valid" : " → Invalid"));
    }
}
```

---

# 10) `LexicalErrors.java` — detect lexical errors: invalid identifiers, unclosed strings, unfinished comments (with line numbers)

Usage: `java LexicalErrors source.c`

```java
// LexicalErrors.java
import java.io.*;
import java.util.regex.*;

public class LexicalErrors {
    static final Pattern ID_PATTERN = Pattern.compile("[A-Za-z_][A-Za-z0-9_]*");
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java LexicalErrors source.c"); return; }
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String line; int lineNo=0;
        boolean inBlockComment=false;
        while ((line = br.readLine())!=null) {
            lineNo++;
            String s = line;
            // check unfinished block comment across lines
            if (inBlockComment) {
                if (s.contains("*/")) { inBlockComment=false; s = s.substring(s.indexOf("*/")+2); }
                else continue;
            }
            if (s.contains("/*")) {
                if (!s.contains("*/")) {
                    System.out.println("Line "+lineNo+": Unfinished comment (/* ... not closed)");
                    inBlockComment=true;
                } else {
                    // ok, remove comment
                    s = s.substring(0, s.indexOf("/*")) + s.substring(s.indexOf("*/")+2);
                }
            }
            // check unclosed string literal in the line
            int quoteCount = 0;
            for (int i=0;i<s.length();i++) if (s.charAt(i)=='"') {
                if (i>0 && s.charAt(i-1)=='\\') continue;
                quoteCount++;
            }
            if (quoteCount%2!=0) System.out.println("Line "+lineNo+": Unclosed string literal");
            // find tokens starting with digit letter combos for invalid identifiers like 1abc
            String[] parts = s.split("\\s+|(?=[;=+\\-*/%(){}\\[\\],])|(?<=[;=+\\-*/%(){}\\[\\],])");
            for (String p: parts) {
                if (p.isEmpty()) continue;
                if (p.matches("[0-9]+[A-Za-z_].*")) {
                    System.out.println("Line "+lineNo+": Invalid identifier (starts with digit): "+p);
                } else if (p.matches("[A-Za-z_].*")) {
                    // verify token is valid identifier when it is identifier-like
                    if (!ID_PATTERN.matcher(p).matches()) {
                        System.out.println("Line "+lineNo+": Invalid identifier characters: "+p);
                    }
                } else if (p.startsWith("\"") && !p.endsWith("\"")) {
                    System.out.println("Line "+lineNo+": Possibly unclosed string: "+p);
                }
            }
        }
        br.close();
    }
}
```

---

# 11) `PreprocessorExtract.java` — extract `#` preprocessor directives

Usage: `java PreprocessorExtract source.c`

```java
// PreprocessorExtract.java
import java.io.*;

public class PreprocessorExtract {
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java PreprocessorExtract source.c"); return; }
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String line;
        while ((line = br.readLine())!=null) {
            String t = line.trim();
            if (t.startsWith("#")) System.out.println(line);
        }
        br.close();
    }
}
```

---

# 12) `KeywordCount.java` — count occurrences of each keyword in source file

Usage: `java KeywordCount source.c`

```java
// KeywordCount.java
import java.io.*;
import java.util.*;

public class KeywordCount {
    static final String[] KEYWORDS = {"int","return","if","while","for","else","break","char","float","double","scanf","printf"};
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java KeywordCount source.c"); return; }
        Map<String,Integer> counts = new LinkedHashMap<>();
        for (String k: KEYWORDS) counts.put(k,0);
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String line;
        while ((line = br.readLine())!=null) {
            line = line.replaceAll("\"(\\\\.|[^\"\\\\])*\"", " "); // remove strings
            String[] tokens = line.split("\\W+");
            for (String t: tokens) {
                if (counts.containsKey(t)) counts.put(t, counts.get(t)+1);
            }
        }
        br.close();
        for (String k: KEYWORDS) System.out.println(k+" : "+counts.get(k));
    }
}
```

---

# 13) `ExtractMultilineComments.java` — print all `/* ... */` blocks or message if none

Usage: `java ExtractMultilineComments source.c`

```java
// ExtractMultilineComments.java
import java.io.*;

public class ExtractMultilineComments {
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java ExtractMultilineComments source.c"); return; }
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuilder sb = new StringBuilder();
        String line;
        boolean inComment = false;
        boolean found = false;
        while ((line = br.readLine())!=null) {
            if (!inComment) {
                int start = line.indexOf("/*");
                if (start!=-1) {
                    inComment=true;
                    found=true;
                    sb.append(line.substring(start));
                    sb.append('\n');
                    if (line.indexOf("*/", start+2)!=-1) {
                        inComment=false;
                    }
                }
            } else {
                sb.append(line).append('\n');
                if (line.contains("*/")) inComment=false;
            }
            if (!inComment && found) {
                // print and reset buffer for next comment
                System.out.print(sb.toString());
                sb.setLength(0);
                found = false;
            }
        }
        br.close();
        if (sb.length()>0) { System.out.print(sb.toString()); }
        if (sb.length()==0 && !inComment) {
            // check if any output printed; if none, print fallback by scanning file
            // Simpler: re-open to check existence quickly
            // Instead, if nothing printed earlier, say no multi-line comments.
            // We'll reopen to be safe:
            BufferedReader br2 = new BufferedReader(new FileReader(args[0]));
            boolean any=false;
            while ((line=br2.readLine())!=null) { if (line.contains("/*")) { any=true; break; } }
            br2.close();
            if (!any) System.out.println("No multi-line comments found.");
        }
    }
}
```

---

# 14) `CharFrequency.java` — frequency of each character in source file

Usage: `java CharFrequency source.c`

```java
// CharFrequency.java
import java.io.*;
import java.util.*;

public class CharFrequency {
    public static void main(String[] args) throws Exception {
        if (args.length!=1) { System.out.println("Usage: java CharFrequency source.c"); return; }
        long[] freq = new long[256];
        FileInputStream fis = new FileInputStream(args[0]);
        int b;
        while ((b = fis.read())!=-1) freq[b & 0xFF]++;
        fis.close();
        // Print letters
        for (char c='a'; c<='z'; c++) if (freq[c]>0) System.out.println("'" + c + "' : " + freq[c]);
        for (char c='A'; c<='Z'; c++) if (freq[c]>0) System.out.println("'" + c + "' : " + freq[c]);
        for (char c='0'; c<='9'; c++) if (freq[c]>0) System.out.println("'" + c + "' : " + freq[c]);
        char[] symbols = {'{','}','(',')',';','[',']',',','<','>','+','-','*','/','=','%','&','|','!','^','~','#',':','\'','\"','\\','\n','\t',' '};
        for (char ch: symbols) {
            long count = freq[ch & 0xFF];
            if (count>0) {
                String label = (ch=='\n')? "'\\n'": (ch=='\t')? "'\\t'": (ch==' ')? "' '": "'" + ch + "'";
                System.out.println(label + " : " + count);
            }
        }
    }
}
```

---

## Final notes & next steps

* These Java programs follow the same behavior as the C versions I previously gave. They’re written to be readable and easily modifiable for extra robustness.
* If you want:

  1. I can create a single `AssignmentRunner.java` that bundles all tasks with command-line options (e.g., `java AssignmentRunner 1 source.c`) — convenient for testing.
  2. Or I can generate a `Makefile`-style shell script to compile all `.java` files and run tests.
  3. Or I can zip all files and give them as one downloadable package.

Tell me which of (1), (2), or (3) you want and I’ll produce it immediately.
